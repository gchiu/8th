#! /usr/local/bin/8th
\ vim: ts=2 sw=2 sts=2 et : 
\ Using 8th to process CGI requests from a web-server

"8thcgi" appname !
true var, wantstime

\ "spit" is the inverse of "slurp"
: f:spit \ x fname --
  f:create swap 
  f:write drop f:close ;

\ If there's an exception, write a log and hopefully let us see it
( dup "/tmp/error.log" f:spit "Error: " . . cr 0 die ) is handler


\ This string will hold (up to 10M of) the stdin or whatever the query string is
"" var, rawvars

\ An map with all the CGI variables we were passed:
var vars

\ List of possible environment variables.  Use "getenv" to access them:
\ AUTH_TYPE The authentication method used to validate a user.
\ CONTENT_LENGTH The length of the data (in bytes or the number of characters) passed to the CGI program through standard input.
\ CONTENT_TYPE The MIME type of the query data, such as "text/html".
\ DOCUMENT_ROOT The directory from which Web documents are served.
\ GATEWAY_INTERFACE The revision of the Common Gateway Interface that the server uses.
\ HTTP_ACCEPT A list of the MIME types that the client can accept.
\ HTTP_FROM The email address of the user making the request. Most browsers do not support this variable.
\ HTTP_REFERER The URL of the document that the client points to before accessing the CGI program.
\ HTTP_USER_AGENT The browser the client is using to issue the request.
\ PATH_INFO Extra path information passed to a CGI program.
\ PATH_TRANSLATED The translated version of the path given by the variable PATH_INFO.
\ QUERY_STRING The query information passed to the program. It is appended to the URL with a "?".
\ REMOTE_ADDR The remote IP address of the user making the request.
\ REMOTE_HOST The remote hostname of the user making the request.
\ REMOTE_IDENT The user making the request. This variable will only be set if NCSA IdentityCheck flag is enabled, and the client machine supports the RFC 931 identification scheme (ident daemon).
\ REMOTE_USER The authenticated name of the user.
\ REQUEST_METHOD The method with which the information request was issued.
\ SCRIPT_NAME The virtual path (e.g., /cgi-bin/program.pl) of the script being executed.
\ SERVER_NAME The server's hostname or IP address.
\ SERVER_PORT The port number of the host on which the server is running.
\ SERVER_PROTOCOL The name and revision of the information protocol the request came in with.
\ SERVER_SOFTWARE The name and version of the server software that is answering the client request.


\ YOUR CODE GOES HERE: \/\/\/\/\/\/\/

: process-response
  vars @ >s
  rawvars @
  quote *
<p>This is the raw query: [%s]</p>
<p>These are the vars: [%s]</p>
  * s:strfmt . ;
  
\ YOUR CODE WENT HERE /\/\/\/\/\/\/\/\

\ Read in all the stdin (from a POST request)
: read-stdin
  f:stdin 
  "" 10000000 f:read 
  drop rawvars ! drop ;

\ if there is no such key, add the key:val 
\ otherwise, turn the value into an array
: m:?! \ o key val -- o
  >r tuck \ key o key (r:val)
  m:exists? \ key o flg (r:val)
  if
    \ key o (r:val)
    \ there is such a key.  get it and convert to an array if not already one:
    over m:@    \ key o curval
    dup >kind ns:a n:= not if
      \ it's not an array, so create one from it
      1 a:close
    then
    \ add in the r:value
    r> a:push >r
  then
  \ and put the value in its place
  swap r> m:!  ;

\ Convert the raw request data into an 8th map for easy handling:
: parse-vars \ s -- o
  \ split params on &
  "&" s:/
  \ for each item in the array of strings, split and insert into the new map
  m:new swap
  (
    \ drop the item index
    nip
    \ split this parameter
    "=" s:/ a:open
    \ o key val
    null? not if net:url> then 
    \ o key val'
    m:?!
  ) a:each drop ;

\ get CGI variables:
: cgi-init
  \ get the POST data:
  read-stdin rawvars @
  \ and the GET data:
  "QUERY_STRING" getenv 
  \ treat them the same and parse them:
  s:+ parse-vars vars !  ;

\ Our response, needs to have a blank line after the HTTP header before the HTML content!
: cgi-header
  quote *
Content-type: text/html;  charset=utf-8

<html>
<head>
  <title>Test response</title>
	<link href='css/8th.css' rel='stylesheet'/>  
</head>
<body>
  * . ;

\ End of our response:
: cgi-footer \ n --
  wantstime @ if
    8thver?
    "<div class='eth'><span>Page generated by <a href='http://8th-dev.com/'>8th %s</a> in %d msec</span></div>"
    s:strfmt .  
  else drop then

  "</body></html>" .  ;

\ The response "sandwich"
: cgi-response
  cgi-init
  cgi-header
  d:msec >r
  process-response 
  d:msec r> n:-
  cgi-footer bye ;

\ This is the main program:
cgi-response
